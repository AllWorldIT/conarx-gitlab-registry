# MR-based release preparation flow
# - Computes next version via semantic-release (dry-run)
# - Updates CHANGELOG.md and commits "chore(release): X.Y.Z"
# - Pushes a temporary branch "release/vX.Y.Z" and opens an MR to the target branch
# - Maintainers review/merge; tagging happens in the follow-up release:tag job
release:prepare:
  stage: release
  image: node:20-alpine
  resource_group: release
  rules:
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'
      when: manual
  variables:
    GIT_STRATEGY: fetch
    GIT_DEPTH: "0" # ensure tags are present for semantic-release dry-run
    GITLAB_TOKEN: $RELEASE_TOKEN
    REPO_URL: "https://oauth2:${RELEASE_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
  before_script:
    - apk add --no-cache git curl bash jq
    - git config --global user.email "project_13831684_bot_1f10d664ae815e69d247c8cd4c319058@noreply.${CI_SERVER_HOST}"
    - git config --global user.name "Registry Release Bot"
  script:
    - |
      set -eo pipefail
      echo "Preparing release branch from $CI_DEFAULT_BRANCH"
      git fetch origin $CI_DEFAULT_BRANCH --prune
      git checkout $CI_DEFAULT_BRANCH
      # Ensure all tags are present for accurate next version computation
      git fetch --tags --prune origin
    - |
      echo "Determining next version via semantic-release (dry run)"
      npx \
        -p semantic-release@21 \
        -p @semantic-release/commit-analyzer@10 \
        -p @semantic-release/release-notes-generator@11 \
        -p @semantic-release/changelog@6 \
        -p @semantic-release/git@10 \
        -p conventional-changelog-conventionalcommits@6 \
        semantic-release --no-ci --dry-run --repository-url "$REPO_URL" | tee /tmp/semantic-release.log || true
      NEXT_VERSION=$(grep -Eo "The next release version is [0-9]+\.[0-9]+\.[0-9]+" /tmp/semantic-release.log | awk '{print $6}' | tail -n1)
      if [ -z "$NEXT_VERSION" ]; then
        echo "No new version to release (semantic-release did not compute a next version). Exiting successfully."
        exit 0
      fi
      echo "Next version: $NEXT_VERSION"
    - |
      echo "Updating CHANGELOG.md using conventional-changelog"
      # Generate only the latest release notes (-r 1) and stage/commit the changelog update
      echo "{\"name\":\"container-registry\",\"version\":\"${NEXT_VERSION}\"}" > /tmp/pkg.json
      npx conventional-changelog-cli@3 -p conventionalcommits -k /tmp/pkg.json -i CHANGELOG.md -s -r 1
      git add CHANGELOG.md
      git commit -m "chore(release): ${NEXT_VERSION}"
    - |
      BRANCH_NAME="release/v${NEXT_VERSION}"
      # Open an MR for review; the tag will be created after merge by release:tag
      git checkout -b "$BRANCH_NAME"
      echo "Pushing branch $BRANCH_NAME to origin"
      git push "$REPO_URL" "$BRANCH_NAME:$BRANCH_NAME"
    - |
      echo "Creating merge request to $CI_DEFAULT_BRANCH"
      : "Require an access token with api scope in RELEASE_TOKEN"
      API_TOKEN="${RELEASE_TOKEN}"
      if [ -z "$API_TOKEN" ]; then
        echo "RELEASE_TOKEN is not set; cannot create MR automatically."
        echo "Manually open an MR from branch $BRANCH_NAME to $CI_DEFAULT_BRANCH ."
        exit 0
      fi
      MR_TITLE="chore(release): ${NEXT_VERSION}"
      curl --fail -sS --header "PRIVATE-TOKEN: ${API_TOKEN}" \
        --data-urlencode "source_branch=${BRANCH_NAME}" \
        --data-urlencode "target_branch=${CI_DEFAULT_BRANCH}" \
        --data-urlencode "title=${MR_TITLE}" \
        --data-urlencode "remove_source_branch=true" \
        --data-urlencode "assignee_id=${GITLAB_USER_ID}" \
        "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests" | jq -r '.web_url // .message'
  artifacts:
    when: always
    expire_in: 7 days
    paths:
      - CHANGELOG.md
      - /tmp/semantic-release.log
