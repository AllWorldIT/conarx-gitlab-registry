# Batched Background Migrations (BBMs)

## Introduction

Batched background migrations provide a mechanism for performing large-scale database migrations efficiently and safely, without compromising system performance or availability. This approach divides extensive migration tasks into smaller, manageable chunks that can be processed incrementally in the background.

The Registry implements a background migration system supporting both asynchronous and synchronous execution modes. In the asynchronous mode, migrations run in the background during normal registry operation, using a worker that periodically checks for and processes pending jobs in batches, minimizing impact on system performance. The synchronous mode enables on-demand execution of background migrations, typically during maintenance operations, offering more immediate processing of migration tasks when necessary.

Key features of the Registry's background migration system include:

1. **Job batching**: Divides migration tasks into smaller, manageable chunks for efficient processing
1. **Flexible execution modes**: Supports both asynchronous (background) and synchronous (on-demand) migration execution
1. **Error handling**: Implements mechanisms to detect, log, and manage issues during migration processes
1. **Comprehensive monitoring**: Provides tools to track migration status
1. **Migration dependencies**: Allows for enforced migrations to ensure critical data changes are completed before dependent operations
1. **Distributed execution**: Uses a locking mechanism to prevent conflicts in distributed environments
1. **Persistence**: Stores migration metadata and job execution details in dedicated database tables for tracking and management

The system is underpinned by two key database tables: the `batched_background_migrations` table for tracking migration metadata, and the `batched_background_migration_jobs` table for recording execution details of individual migration jobs. A distributed lock mechanism ensures that only one instance processes a given migration at a time, preventing conflicts in distributed environments. This architecture enables the Registry to seamlessly execute complex database operations while maintaining data consistency and enhancing overall system reliability.

## Structure

The Registry's implementation of batched background migrations draws inspiration from the GitLab Rails background migration system, with some minor differences tailored to the Registry's specific needs. While the core concept remains similar, the Registry's implementation includes additional/modified fields. For more details on the Rails inspiration, you can refer to [the GitLab database structure](https://gitlab.com/gitlab-org/gitlab/-/blob/master/db/structure.sql?ref_type=heads#L7059). The Registry's batched background migration tables are structured as follows:

### Database Schema

#### Migrations

```sql
CREATE TABLE batched_background_migrations (
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    name text NOT NULL,
    created_at timestamp WITH time zone NOT NULL DEFAULT now(),
    updated_at timestamp WITH time zone,
    min_value bigint DEFAULT 1 NOT NULL,
    max_value bigint NOT NULL,
    batch_size integer NOT NULL,
    status smallint DEFAULT 0 NOT NULL,
    job_signature_name text NOT NULL,
    table_name text NOT NULL,
    column_name text NOT NULL,
    CONSTRAINT pk_batched_background_migrations PRIMARY KEY (id),
    CONSTRAINT unique_batched_background_migrations_name UNIQUE (name)
);
```

- `id`: Unique identifier for the migration (auto-generated).
- `name`: A unique name that identifies the migration (ideally, all names should follow the format `<timestamp>_<migration_description>`).
- `created_at`: Timestamp when the migration was created.
- `updated_at`: Timestamp when the migration was last updated.
- `min_value`: Starting row `id` eligible for migration.
- `max_value`: Stopping row `id` eligible for migration. Used to exclude newly introduced records after a given point.
- `batch_size`: Number of rows that should be migrated per batch.
- `status`: The current state of the migration (see table below).
- `job_signature_name`: The key that corresponds to a registry function that will be executed for each batch of the migration.
- `table_name`: The table the migration is run on. Must follow the format `<schema>.<table>`.
- `column_name`: The column used to determine the next batch.

Status values:

| status     | value | description                                                                                                                                                                                       |
| ---------- | ----- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `paused`   | 0     | No new jobs for the migration will be created/run, and no failed jobs will be retried. Already active jobs updated to this status will be allowed to either run to successful completion or fail. |
| `active`   | 1     | The migration is ready to be picked up as soon as a job worker is available.                                                                                                                      |
| `finished` | 2     | The migration is complete (all batched jobs have run successfully and the migration has reached its batching bounds).                                                                             |
| `failed`   | 3     | The migration is marked as `failed` when at least one of the migration jobs has exceeded the maximum retry `attempts`. Manual intervention is required at this stage.                             |
| `running`  | 4     | The migration is ongoing (at least one job associated with the migration is not completed).                                                                                                       |

#### Jobs

```sql
CREATE TABLE batched_background_migration_jobs (
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    created_at timestamp WITH time zone NOT NULL DEFAULT now(),
    updated_at timestamp WITH time zone,
    started_at timestamp WITH time zone,
    finished_at timestamp WITH time zone,
    batched_background_migration_id bigint NOT NULL,
    min_value bigint NOT NULL,
    max_value bigint NOT NULL,
    status smallint DEFAULT 1 NOT NULL,
    failure_error_code smallint,
    attempts smallint DEFAULT 0 NOT NULL,
    CONSTRAINT pk_batched_background_migrations_job PRIMARY KEY (id),
    CONSTRAINT fk_b_b_m_jobs_batched_background_migration_id_b_b_migrations 
        FOREIGN KEY (batched_background_migration_id) 
        REFERENCES batched_background_migrations(id) 
        ON DELETE CASCADE
);

CREATE INDEX idx_bbm_jobs_migration_id_status ON batched_background_migration_jobs (batched_background_migration_id, status);
CREATE INDEX idx_bbm_jobs_status ON batched_background_migration_jobs (status);

```

- `batched_background_migration_id`: References the batched background migration the job is tied to.
- `min_value`: The starting `id` for the batch job.
- `max_value`: The stopping `id` for the batch job.
- `attempts`: How many times the batch job was tried.
- `status`: The current state of the job:

| status     | value | description                   |
| ---------- | ----- | ----------------------------- |
| `active`   | 1     | The job is in progress.       |
| `finished` | 2     | The job has finished.         |
| `failed`   | 3     | The job has failed.           |

- `failure_error_code`: The last error code associated with a `failed` job state. This corresponds to error codes emitted by the registry when a job fails:

| error code              | value | description                                                     |
| ----------------------- | ----- | --------------------------------------------------------------- |
| `unknown`               | 0     | The job/migration failed with an unknown error code             |
| `invalid_bbm_table`     | 1     | Invalid migration table reference                               |
| `invalid_bbm_column`    | 2     | Invalid background migration column reference                   |
| `invalid_job_signature` | 3     | Invalid job signature reference                                 |
| `max_job_retry`         | 4     | A migration's job exceeded the maximum configured retry attempt |

## Creation

Batch Background Migrations (BBMs) are created by adding a new migration into the normal schema migrations. This process involves several steps:

1. Create a new schema migration file:
   - Add a new file in the migrations directory with a timestamp prefix, e.g., `20240815000000_add_new_bbm.go`.

1. Define the migration:
   - Implement both `Up()` and `Down()` methods.
   - In the `Up()` method, insert a record into the `batched_background_migrations` table.
      - Include all necessary fields: `name`, `job_signature_name`, `table_name`, `column_name`, `min_value`, `max_value`, `batch_size`, and `status`.
   - In the `Down()` method, remove the record from the `batched_background_migrations` table.

1. Implement the migration logic:
   - Create a new file `registry/datastore/migrations/background/{{name}}.go` to define your work function.
   - In this file, implement the work function that will be executed for each batch. The function should conform to the `WorkFunc` type defined in `registry/bbm/bbm.go`:

     ```go
     func YourMigrationFunction(ctx context.Context, db datastore.Handler, paginationTable, paginationColumn string, paginationAfter, paginationBefore int64, limit int) error {
         // Implement your migration logic here
     }
     ```
     
   - Register your function in the `AllWork` map within `bbm.go`:

     ```go
     // In bbm.go
     var AllWork = map[string]WorkFunc{
         "your_job_signature_name": YourMigrationFunction,
     }
     ```

   > **Important Notes:**
   > 
   > 1. **Function Naming:** The `your_job_signature_name` key in the `AllWork` map must match the `job_signature_name` specified in the BBM record. This ensures proper function lookup and execution.
   >
   > 1. **Idempotency:** Work functions must be idempotent to guarantee safe retries. This means:
   >    - Executing the same function multiple times with identical input should produce the same result.
   >    - The function should not have unintended side effects on repeated executions.
   >    - Idempotency is critical for maintaining data integrity during retries and recovering from failures.

## Execution

### Asynchronously

Asynchronous BBMs run in the background during normal registry operation, minimizing impact on system performance.

Process:

1. Initialization: A BBM is created through a regular database migration, inserting a record into the batched_background_migrations table.
1. Worker Activation: Registry instances periodically start a worker to check for active BBMs.
1. Lock Acquisition: The worker attempts to acquire a distributed lock to ensure only one instance processes a migration at a time.
1. Migration Processing:
   1. If a lock is acquired, the worker fetches an active BBM.
   1. It creates a new job in the `batched_background_migration_jobs` table or picks up a failed job for retry.
   1. The worker executes the job using the function specified by `job_signature_name`.
   1. Upon completion, it updates the job status and releases the lock.
1. Completion: This process repeats periodically until all jobs for the BBM are completed or the maximum retry attempts are reached.
1. Status Update: The BBM status is updated to 'finished' or 'failed' based on the outcome.

```plantuml
actor "Registry Instance" as RI
participant "BBM Worker" as Worker
database "Database" as DB
participant "Lock Mechanism" as Lock

RI -> Worker: Start
activate Worker

loop periodically
    Worker -> Lock: Attempt to acquire lock
    activate Lock
    alt Lock acquired
        Lock --> Worker: Lock granted
        Worker -> DB: Fetch active BBM
        activate DB
        DB --> Worker: Return BBM details
        Worker -> DB: Create/Fetch job
        DB --> Worker: Job details
        Worker -> Worker: Execute job
        Worker -> DB: Update job status
        Worker -> DB: Update BBM status if complete
        deactivate DB
        Worker -> Lock: Release lock
    else Lock not acquired
        Lock --> Worker: Lock denied
    end
    deactivate Lock
end
deactivate Worker

```

## Synchronously

Synchronous BBMs are executed manually via the registry CLI process, allowing registry administrators to directly manage migrations. Synchronous migration runs offer a higher level of urgency compared to asynchronous migrations, as they attempt to run migrations to completion without interruption. By using the CLI, administrators can initiate, monitor, and verify the completion of these migrations in real-time, providing immediate results and a higher level of control over the migration process. This approach is particularly useful for time-sensitive database updates or when immediate migration completion is required.

Process:

1. Admin initiates process via CLI command.
1. Migration Worker starts and unpauses migrations.
1. Migrations are run until all migrations complete or critical error occurs:
   - Begin transaction and acquire lock.
   - Process jobs in batches within transaction (up to a maximum).
   - Handle job execution, retries, and error reporting.
   - Commit transaction and release lock after transactional batch completion.
1. Process terminates with success or failure report to admin.

```plantuml
actor Administrator
participant "CLI Command" as CLI
participant "Migration Worker" as Worker
database "Database" as DB

Administrator -> CLI: Initiate synchronous migration
activate CLI

CLI -> Worker: Start migration process
activate Worker

Worker -> DB: Unpause migrations

  loop until all migrations processed or critical error
      Worker -> DB: Begin transaction and acquire lock
      activate DB
    
      loop until max jobs per transaction or no more jobs
          Worker -> DB: Find next eligible job
          DB --> Worker: Job details
        alt all jobs completed successfully
           Worker -> CLI: Report successful completion
           CLI -> Administrator: Display success message and terminate
          else pending job found
              loop retry attempts
                  Worker -> Worker: Execute job
                  alt job succeeds
                      Worker -> DB: Mark job as completed
                      break
                  else job fails
                      Worker -> Worker: Log error and retry
                  end
              end
            
              alt max retries exceeded
                  Worker -> CLI: Report critical error
                  CLI -> Administrator: Display error and terminate
                  break
              end
          else no job found
              Worker -> DB: Update migration status if needed
              break
          end
         end
      end
   end
end
    Worker -> DB: Commit transaction and release lock
    Worker -> Worker: Introduce delay before next transaction batch
end

deactivate Worker
deactivate CLI
```

## Retry and Recovery

Each Migration is run once and each job in a migration can be run up to a configurable number of attempts. The behavior differs between asynchronous and synchronous processes:

1. For asynchronous BBM runs:
   - Uses a default maximum job attempt value of 5.
   - All migration jobs are guaranteed to be run only once before any failed jobs can be retried.
   - After all jobs have been run at least once, the registry then proceeds to run each failed job up to the default maximum job attempt value.
   - If any of the failed job's retry attempts (from `attempts` in `batched_background_migration_jobs` table) exceeds the default maximum (of 5), the migration is marked as failed regardless of other successful jobs in the BBM.
   - The `attempts` field in the database is updated for each retry.

1. For synchronous BBM runs during regular migrations:
   - Uses the `--max-job-retry` flag value provided in the CLI, which can be set between 1 and 10 (default is 2).
   - The process exits and returns an error if a job exceeds the maximum attempts provided in the CLI.
   - The `attempts` field in the database is not updated during synchronous runs, preserving the database state.

A failed BBM is not automatically retried and will require manual intervention to restart the BBM or investigate the issue. Failed BBMs are rare but if/when they do happen, they require investigation. On `GitLab.com`, we raise an error on Sentry whenever a BBM is marked as failed.

Ultimately, a failed BBM does not degrade the registry when it happens as part of the asynchronous BBM. It is up to the registry developer to enforce that a BBM is completed (using the assurance mechanism explained in [Finalizing BBM](#finalizing-a-bbm)) before using functionality introduced by the BBM within the registry codebase.

_Note_: A failed BBMs can always be re-run by using the [`background-migrate run` sub-command](#cli)

## CLI

The CLI exposes the following functionality for managing batched background migrations:

- `background-migrate status`: Show the current status of all batched background migrations. This command displays a table with the name and status of each migration, allowing users to monitor migration progress and audit the system.

- `background-migrate pause`: Pause all running or active batched background migrations. This command can be used to temporarily halt the execution of background migrations.

- `background-migrate resume`: Resume all paused batched background migrations. This command can be used to restart the asynchronous execution of previously paused background migrations.

- `background-migrate run`: Run all unfinished batched background migrations. This command executes any pending or failed migrations.

These CLI commands provide administrators with the necessary tools to manage, monitor, and control the execution of batched background migrations in the registry.

## Release process

### Introducing a new BBM

It is important to always introduce a background migration well in advance of any feature that uses the functionality introduced by the migration. This ensures that customers have had sufficient time to and headroom for the BBM to run to completion.

### Finalizing a BBM

Finalizing a BBM is required to ensure that code or schema migrations that rely on the BBM do not accidentally run before the BBM is complete. When introducing a BBM or a regular migration that depends on an existing BBM, we must ensure the existing BBM is complete before proceeding with the introductory schema migration.

This is handled in two ways:

1. For schema migrations: Specify the name(s) of the dependent BBM(s) in the `RequiredBBMs` field of a migration. Now when a `migrate up` command is run it will verify that all specified BBMs are complete before applying the migration.

1. For code paths: Use the BBM datastore method `AreFinished` to assert that the background migration(s) the code change depends on have finished.

This approach ensures that schema migrations and code changes stop the registry from proceeding until the required/dependent BBMs are fully complete, maintaining data integrity and preventing potential issues.

```plantuml
actor "Administrator" as Admin
participant "Migrator" as Migrator
participant "BackgroundMigrationStore" as BBMStore
database "Database" as DB

Admin -> Migrator: Initiate migrate up
activate Migrator

Migrator -> Migrator: Get eligible migrations from source
Migrator -> DB: Get applied migration records in database

loop for each eligible migration
    Migrator -> Migrator: Check if migration is already applied
    alt migration not applied
        Migrator -> Migrator: Check for required BBMs
        alt BBMs required
            Migrator -> BBMStore: Check BBM completion status
            alt BBMs not complete
                Migrator --> Admin: Return error (BBM not complete)
                break
            end
        end
        Migrator -> DB: Apply migration
        Migrator -> Migrator: Increment applied count
    end
    alt max migrations reached
        break
    end
end
end
end

Migrator --> Admin: Return number of applied migrations

deactivate Migrator
```

### Required stops

A [required stop](https://docs.gitlab.com/ee/development/database/required_stops.html) is a perfect place to enforce a BBM dependency on a regular migration. [TBD](https://gitlab.com/gitlab-org/container-registry/-/issues/1346)

## Out of scope of first iteration

- Concurrent migration processing: To reduce complexity, for the first iteration only one migration and one job can be run at a time.

- Batching strategy: To reduce complexity the first iteration will only support primary key batching (i.e. creating job batches based on a primary key). This is the default in rails.

- Sub batching: It is often beneficial to run a dedicated migration query in a job batch on one "sub" batch (a smaller division of your batch) at a time. Although this is very useful I think we can consider introducing this when the need arises, for the time being we can make our batch small enough to satisfy our own constraints.

- Dynamic optimization of batch sizes: Rails can optimize the batch size per job based on how long a prior job took.

- API for status: While having an API to gauge the migration status would be nice, it wouldn't add a huge benefit than having the CLI command for checking the status, especially given as only admins will be able to access the APIs anyway.

- Down migrating BBM.
